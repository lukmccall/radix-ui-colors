#!/usr/bin/env bun

import Colors from "@radix-ui/colors";
import path from "node:path";
import fs from "node:fs";

const colorsKt = path.resolve(
  __dirname,
  "../library/src/commonMain/kotlin/RadixColor.kt"
);

const palletExtensionKt = path.resolve(
  __dirname,
  "../library/src/commonMain/kotlin/RadixPalletExtension.kt"
);

type RGBValue = {
  r: number;
  g: number;
  b: number;
  a: number;
};

function isDark(color: string): boolean {
  return color.includes("Dark");
}

function isP3(color: string): boolean {
  return color.includes("P3");
}

function isAlpha(color: string): boolean {
  return color.endsWith("A");
}

function parseColorName(colorName: string): {
  name: string;
  isDark: boolean;
  isP3: boolean;
  isAlpha: boolean;
} {
  const isDarkColor = isDark(colorName);
  const isP3Color = isP3(colorName);
  const isAlphaColor = isAlpha(colorName);

  // Remove suffixes to get the base color name - handle all combinations
  let name = colorName.replace(
    /DarkP3A$|DarkP3$|DarkA$|P3A$|Dark$|P3$|A$/g,
    ""
  );

  return {
    name,
    isDark: isDarkColor,
    isP3: isP3Color,
    isAlpha: isAlphaColor,
  };
}

function parseP3Color(color: string): RGBValue {
  // color(display-p3 0.282 0.141 0.996 / 0.055)
  // or color(display-p3 0.282 0.141 0.996) - alpha is optional
  const match = color.match(
    /color\(display-p3\s+([0-9.]+)\s+([0-9.]+)\s+([0-9.]+)(?:\s*\/\s*([0-9.]+))?\)/
  );

  if (!match) {
    throw new Error(`Invalid P3 color format: ${color}`);
  }

  return {
    r: parseFloat(match[1]),
    g: parseFloat(match[2]),
    b: parseFloat(match[3]),
    a: match[4] ? parseFloat(match[4]) : 1.0,
  };
}

function hexToRgb(hex: string): RGBValue {
  const match = hex.match(/^#([0-9a-fA-F]{6})([0-9a-fA-F]{2})?$/);
  if (!match) {
    throw new Error(`Invalid hex color format: ${hex}`);
  }

  const r = parseFloat(
    (parseInt(match[1].substring(0, 2), 16) / 255).toFixed(7)
  );
  const g = parseFloat(
    (parseInt(match[1].substring(2, 4), 16) / 255).toFixed(7)
  );
  const b = parseFloat(
    (parseInt(match[1].substring(4, 6), 16) / 255).toFixed(7)
  );
  const a = match[2]
    ? parseFloat((parseInt(match[2], 16) / 255).toFixed(7))
    : 1.0;

  return { r, g, b, a };
}

function rgbaStringToRgb(rgba: string): RGBValue {
  const match = rgba.match(
    /rgba?\(\s*([0-9]+(?:\.[0-9]+)?)\s*,\s*([0-9]+(?:\.[0-9]+)?)\s*,\s*([0-9]+(?:\.[0-9]+)?)\s*(?:,\s*([0-9]+(?:\.[0-9]+)?)\s*)?\)/
  );
  if (!match) {
    throw new Error(`Invalid RGBA color format: ${rgba}`);
  }

  const r = parseFloat(match[1]);
  const g = parseFloat(match[2]);
  const b = parseFloat(match[3]);
  const a = match[4] ? parseFloat(match[4]) : 1.0;

  return { r, g, b, a };
}

function valuesToRgb(values: string[], isP3: boolean): RGBValue[] {
  return values.map((value) => {
    if (isP3) {
      return parseP3Color(value);
    } else if (value.startsWith("#")) {
      return hexToRgb(value);
    } else {
      return rgbaStringToRgb(value);
    }
  });
}

type ParsedColor = {
  light?: RGBValue[];
  lightP3?: RGBValue[];
  lightAlpha?: RGBValue[];
  lightP3Alpha?: RGBValue[];
  dark?: RGBValue[];
  darkP3?: RGBValue[];
  darkAlpha?: RGBValue[];
  darkP3Alpha?: RGBValue[];
};

function RGBValuesToString(
  rgbValues: RGBValue[] | undefined,
  isP3: boolean
): string {
  const className = isP3 ? "RawColor.P3" : "RawColor.SRgb";
  if (!rgbValues || rgbValues.length === 0) {
    return "";
  }
  return rgbValues
    .map(
      (value) =>
        `${className}(${value.r}f, ${value.g}f, ${value.b}f, ${value.a}f)`
    )
    .join(", ");
}

const colorMap: Record<string, ParsedColor> = {};

Object.entries(Colors).forEach(([color, values]) => {
  const colorInfo = parseColorName(color);
  const parsedValues = valuesToRgb(Object.values(values), colorInfo.isP3);

  const currentValue = colorMap[colorInfo.name] || ({} as ParsedColor);

  const colorKey = `${colorInfo.isDark ? "dark" : "light"}${
    colorInfo.isP3 ? "P3" : ""
  }${colorInfo.isAlpha ? "Alpha" : ""}` as keyof ParsedColor;

  currentValue[colorKey] = parsedValues;
  colorMap[colorInfo.name] = currentValue;
});

const fileStream = fs.createWriteStream(colorsKt, {
  flags: "w",
  encoding: "utf-8",
});

fileStream.write(
  `// This file is auto-generated by scripts/sync-colors.ts\n\n`
);
fileStream.write(`package io.github.lukmccall.colors\n`);
fileStream.write(`\n`);
// fileStream.write(`enum class RadixColorName {\n`);
// Object.keys(colorMap).forEach((colorName) => {
//   fileStream.write(`  ${colorName.toUpperCase()},\n`);
// });
// fileStream.write(`}\n`);
// fileStream.write(`\n`);
fileStream.write(`enum class RadixColor(\n`);
fileStream.write(`  internal val solid: DayNightColor,\n`);
fileStream.write(`  internal val alpha: DayNightColor,\n`);
fileStream.write(`  internal val p3: DayNightColor,\n`);
fileStream.write(`  internal val p3Alpha: DayNightColor,\n`);
fileStream.write(`) {\n`);
Object.entries(colorMap).forEach(([colorName, colorData]) => {
  fileStream.write(
    `  ${colorName.toUpperCase()}(
    solid = DayNightColor(listOf(${RGBValuesToString(
      colorData.light,
      false
    )}), listOf(${RGBValuesToString(colorData.dark, false)})),
    alpha = DayNightColor(listOf(${RGBValuesToString(
      colorData.lightAlpha,
      false
    )}), listOf(${RGBValuesToString(colorData.darkAlpha, false)})),
       p3 = DayNightColor(listOf(${RGBValuesToString(
         colorData.lightP3,
         true
       )}), listOf(${RGBValuesToString(colorData.darkP3, true)})),
      p3Alpha = DayNightColor(listOf(${RGBValuesToString(
        colorData.lightP3Alpha,
        true
      )}), listOf(${RGBValuesToString(colorData.darkP3Alpha, true)})),
    
  ),\n`
  );
});
fileStream.write(`}\n`);
fileStream.end();

const palletExtensionStream = fs.createWriteStream(palletExtensionKt, {
  flags: "w",
  encoding: "utf-8",
});

palletExtensionStream.write(
  "// This file is auto-generated by scripts/sync-colors.ts\n\n"
);
palletExtensionStream.write(`package io.github.lukmccall.colors\n`);
palletExtensionStream.write(`\n`);
Object.keys(colorMap).forEach((colorName) => {
  palletExtensionStream.write(
    `val <T> RadixPallet<T>.${colorName}: RadixPallet<T>.SelectedColor\n`
  );
  palletExtensionStream.write(
    `  get() = this[RadixColor.${colorName.toUpperCase()}]\n\n`
  );
});
palletExtensionStream.end();
